// SPDX-License-Identifier: MIT

/**
ccloool:::cc::::cc:::::cccccloooooool;;loddc...............,:'....''...,cc...''...,ll.................';:;,',,'',,;,';:;;:lll::clc;;;;;
ccccllc:::cc:::::::::::c:clccllloolllooooodo,.............,loc'.......:dkkl,;odooodxxl:;;'..............',...........''.';ccc:;:c;....'
::::::::::cc::::::;;:::cclllcccloooollloooddl:,,;:,...';clooddo,.....,lxkkxxxkkkxxxxxddxxdoc,.':cllc;'.....''.''..........,,,'.''......
::::::;;:;::;;;;;;;::::ccclllccllllllloooooooooooool:clddddddddo:..';ldxkkxxxxxxxxxxdxxdddxxdodxxxxxxxo:,'cdddxxdolldl::,.........;clc'
:;;;;;:;:;:;;;;:::;;:::::cclccllccllllddolodoooooddododddodoodxddoodddoxkxxxxxxxdxxddxxdooddoddxkxxkkkkkxdkOxxkOOkkOOkkko:,'';c:';dkOkd
;,,,;;;;::;;,,;;::;,;:;;::cccccccllllllolooooooooooooollooloooodddoooddxkxddxxddddxddxxoodddddddxxxkkkkkkxkkxkkkkkkxkOkxkOOxxkkkxxkkOOO
,,,,;;,;;;,,,,;;;;;,;;;;;::::ccclollccclloollllloolllllcccclooodoodddddddxdodddddddddddddddddooodddxkxkOkxkxxkOkkkxxkkOkkkOOOkkOOkxkkkO
',,,,,',,,,,,,,,,'',,,,',,;::ccccccclcccloollolllolllcclccllccloooddddoodxddxddxdoooododdoloolodxdddxxxkkkxxkkOkkkkkkxxdxkkkOOkkOkxkkxk
'',,,'''''''''''....'''''',;::::::cc:c::clc:clllllllllcccc:ccclloodxdoodooooddddoooooooooollooooodxxxkxkkxkxkkkkkkxxkxxdxkkkkxxkkkxkOkx
'''''..'''...''........''..',,,,;:c:;;;;:c::cccccclllcccc::::cclllodooloolloddooolllloololcclollddddxkxddkkxxkkkxxxxkkkkxxkkxxdkOkkxxkO
.............................''',,,,,,,;::::::cc::::ccc::;;;;;::clccccllollllooollccccllccccclllooooodxddxxxxkxxxxxxxkkkkxxxdxxxkkxxxxx
.......................................',,;:;;;:;;;;;:;;,,,,,,;;:cc:::cllc:cccllcccc:;:c::::ccccllooodddddkkxxxxddxxxxxxxxxddxxxxkkxxxx
..........................................''',,,,;;,,,''......'',;;,,,;:::;:::cc::::;:::;;;;;;;:ccllooolododddxdddxxxddxddxxxdodxxxxxdd
..................'',,..,;;...................''.''''.................'',;;;;:::;,,,,,,'''..',,;:cccllloooloddxoodxkxddodddxxoodxddddoo
...............',;;;;coxxxkxolllc:,........';coddol:'.............:lllll;'''',,,..;coddddol:,...,;:oxkxxolloodddkOO0kdoooodddoooddoddoo
.....',,;,',,,,,,;;;,:OXXXXXXXXXXXKOd:;;,:dOKXXXXXXXOl'....,,;:;;xKXXXN0;......;lk0XXXXXXXXX0xc...,kXXXklllclold0XXKklllllooolloooooooo
'',,,,,,,,,,',,,,,,,'l0XXKkddxxxOKXXXx:;;lkKOxdllxKXXKd;;;;:::lkKXXXXXX0c..'',o0XXXKkdddoxOKXXO:..,OXXKo,;;:clcdKXX0dccc::ccccccclllccl
''',,'',,,,''''''''''oXXXk:,,,;,:OXXXx;,;,;c;,,,,c0XXXd,',;,;d0XX0KXXXXkc:::oOXXX0xl:::;;:coxoc:;'lKXXO,..'.',;xXXXOc,,''',,;,,;:cc:::c
'''''''''''''''''''.,xXXXOdoooddOKXKk:'',,'':oddx0XXKx;''',lkKXKdo0NXXKo::::xXXX0o;;::;;;:::;::::cOXXX0dlllllooOXXKo'...........,;;;,,;
'...'...''....'.....;OXXXXXXXXXXXXXx;...''.'oXNXXXXKo,''.;dKXKxc,lKXXX0c,;,cOXXXd;,,;;;,;;,;;;;::l0XXXXXXXXXXXXXXX0c',;clc:;,;;........
....................cKXX0ollllodOXXKo'......:oooxKXX0c..cOXXXOolokXXXX0ol;.:OXXXd''',,,,,''',,,,,l0XXKOkkxkxxk0XXX0lclllccclloo:,'..,,'
....................dXXXd'......oKXXk'...'.......dXXXx.'kNXXXXXXXXXXXXXNK:.'dXXX0c'..''''';l:,'',dKXXOl:::::clkXXXkc::cc::::ccc:c:;;;;,
...................'kXXXkcccclld0XXKo..;d0kl:;;:o0XXKl..clllllllxKXXXKdlc...'xXXXKxlc::clx0X0o'.,xXXXx;,,;;;:l0XXKd::::::;;::c:;;;,''..
...................;0NXXXXXXXXXXXKkc...l0XXXXKKXXXKOc...........cKXXXO;.......ckKXXXXXXXXXX0d:..;OXXKc....',;oKXX0c,'''',',;;;;'.......
...................,ooooooooooolc,...',,:lx000KKKOd;...,:;......:k000Oxooc;;;:clllodxxxdol:'....'lddl'......':oodc'.........'.........,
.................................':codxxooddxkxxkxxocodxkkxdoooccododdxxddxkxxkxoc;;;,..''',;'...........'...........'...........';coox
................................,cxxxkxdxxdodxddodxddxkxdxkxdddoooooddodddxxdxkxoodddollddooddo:'.,cl:::ll:'..':lc::lollccc,'..'cdxdxxx
....................;c:;;col:;:llooxkxxdodxdoodxdolodxxoloddkdlooodxdodxxddddddxdododdoooooooddollooddoolllc:clodxdooodxddxxdlooxxddkOk
::;;;;:;'...';;cc:cloodoodooolllllloxxdllddoxdoddooooddoddooddddolldooddloollllooloooooddoloolodolloooodoooolooloooolodxxdodooooxxoodxo
dlclocldolllccclooolloolol:cooolccclllollodooooollooccloollodddoloolllolldlcllooooodocclooloolllllollloxolollccoollooolodloollllddlcodl
:lccllolcoool::cclllllc:ccccllcc::lccldollccc:lolcllcllol:cclooollllloolllccldllllll::cc:ccloodolcccccloccc:ccccoolllooooodoloccddlcddo
cccccc::c:cllc:::c::cccclclc:cc;;:::::cccc:;::cllccc:clllc:lcccclclllool::ccclc:ll::cccc:::ccccccc:::lllccc:::cclccllcccloollcc:looooll
c:,,,,;;:;;;::;;,,;;:::::::;,,;,;:;;;::::cc::;,;:cc::cllcc:clol::;:cccllc:;:cc:;:;;cl:;;;;;;;;,;c:;;;:clc;;::::;;;;:cccccll:clc:ldolc;:
,,,,,,,,'',,,,,,;:;,,,,',,,,,,;,,,''',,,,,'',,,,,;:;;:::;:;;cc::;;::::::;,,,',;,,',;:;,''',,,,,;,'',,',,,,,,,;,,,,,;;;:;:clc:c:cddc:ccc
..'...........''''''....''...''..............'..'''''';:;,,',,',,,,,;:,,,'''..'...''.....''...''..'''''.........'..',;;,,,,,:;,:ol;;;;,
...........................................................''''''''..'..'.'...........................................'.','''..;dc,'''.
,;;;;;;;;,,,''''.......'',,;;::cccccccccccc::;;,'..............................',;;::cccc::;;,,'''''',,;;:::cc:;,'.............lx:'....
0KK0KKKK0000OOOOOkOOOOOO0000KKKKKKKKKKKKKKKKKKKK0Okdolc:;;,'''''',,,,;::clodxkO00KKKKKKKXKKKKK00000000KKKKKKKKKKKOkdl:,.......cOx,....;
KKKKKKKK00KKK0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KKKKK00K00000000KK0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0Oxddddk0Ko..:ok0
KKKKKKKKKKKKKKK00KKKKKKKKKKKK0KKKKKKKKK0KKKKKKKKKKK0KKK00KKKKK00KKKKKK00KKKKKKKKKKKKKKKKKKKK00KKKKKKKKKK00KKKKKKKKKKKKKKKKKKK0KKl'oKK00
*/

pragma solidity ^0.8.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import "@openzeppelin/contracts/interfaces/IERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC721.sol";

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

import "./BeachLibrary.sol";

interface IERC20Burnable {
  function burnFrom(address account, uint256 amount) external;
}

interface ISeafood {
  function decimals() external view returns (uint8);
}

contract Beach is ERC721, ERC721Enumerable, ERC721Royalty, Ownable {
  uint private _tokenIdCounter = 0;
  bool private _revealed = false;
  string private _baseURIPath = "https://lobby.mypinata.cloud/ipfs/";
  string private _placeholderURI = "QmZc5HkKqUf1UiL9xqpanvbETB83Ter21AqMRUo1mbv9PN";
  string[2] private _revealedPath = ["", ""];
  bool private _freezeBasePath = false;

  // TODO: Add the waveListMerkleRoot
  bytes32 public waveListMerkleRoot = "";
  uint public MAX_SUPPLY = 1337;
  string public provenance = "";

  address private _lobster;
  address private _seafood;

  uint private _mintBlock;

  string[] private _TRAITS = ["SAND", "WATER", "WAVES", "SPARKLING", "LOCATION", "FRAME", "FEATURE", "SIGN"];
  string[] private _DICT;

  mapping(uint256 => string) private _beachNames;
  mapping(uint256 => uint16[8]) private _beachMetadata;
  mapping(string => bool) private _existingNames;

  uint private AMOUNT_NEEDED_FOR_NAME_CHANGE = 50;

  mapping(address => uint8) private _shares;
  mapping(address => uint256) private _released;
  mapping(address => uint256) private _balances;
  address[] private _payees;
  uint256 private _totalShares;
  uint256 private _totalSplit;
  uint256 private _amountReleased;

  event PayeeAdded(address account, uint8 shares);
  event PayeeUpdated(address account, uint8 shares);
  event PaymentReleased(address account, uint256 amount);
  event NFTMinted(uint256 tokenId, address mintedBy);
  event Revealed();
  event PathUpdated(string path);
  event NameChanged(string name);

  constructor(address lobster_, address seafood_, address[] memory accounts_, uint8[] memory shares_, uint blocksBeforeTheMint_) ERC721("Beach", "BEACH-NFT") {
    _lobster = lobster_;
    _seafood = seafood_;

    for (uint8 i = 0; i < accounts_.length; i++) {
      _addPayee(accounts_[i], shares_[i]);
    }

    _setDefaultRoyalty(address(this), 1000);

    _mintBlock = block.number + blocksBeforeTheMint_;
  }

  function setSeafood(address seafood_) external onlyOwner {
    _seafood = seafood_;
  }

  receive() external payable {
  }

  /**
   * @dev Returns the wallet of a given wallet. Mainly for ease for frontend devs.
   * @param _wallet The wallet to get the tokens of.
   */
  function walletOfOwner(address wallet_)
  public
  view
  returns (uint256[] memory)
  {
    uint256 tokenCount = balanceOf(wallet_);

    uint256[] memory tokensId = new uint256[](tokenCount);
    for (uint256 i; i < tokenCount; i++) {
      tokensId[i] = tokenOfOwnerByIndex(wallet_, i);
    }
    return tokensId;
  }

  function _baseURI() internal view override returns (string memory) {
    return _baseURIPath;
  }

  modifier pathNotFrozen() {
    require(!_freezeBasePath, "BEACH: Base Path frozen");
    _;
  }

  function _updateBaseURI(string memory uri_) private pathNotFrozen {
    _baseURIPath = uri_;
  }

  // Function intended to be triggered by the DAO in case the Gateway or Network has an issue
  function updateBaseURI(string memory uri_) external onlyOwner {
    _updateBaseURI(uri_);
  }

  function freezeBasePath() external onlyOwner pathNotFrozen {
    _freezeBasePath = true;
  }

  function getRevealedPath(uint256 tokenId_) public view returns (string memory) {
    return tokenId_ < 1000 ? _revealedPath[0] : _revealedPath[1];
  }

  /**
   * @dev Hash to metadata function
   */
  function hashToMetadata(uint tokenId_)
  public
  view
  returns (string memory)
  {
    string memory metadataString;

    for (uint8 i = 0; i < _beachMetadata[tokenId_].length; i++) {
      metadataString = string(
        abi.encodePacked(
          metadataString,
          '{"trait_type":"',
          _TRAITS[i],
          '","value":"',
          _DICT[_beachMetadata[tokenId_][i]],
          '"}'
        )
      );

      if (i < _beachMetadata[tokenId_].length - 1)
        metadataString = string(abi.encodePacked(metadataString, ","));
    }

    return string(abi.encodePacked("[", metadataString, "]"));
  }

  function contractURI() public view returns (string memory) {
    return "https://metadata-url.com/my-metadata";
  }

  /**
   * @dev Returns the metadata for a token Id
   * @param _tokenId The tokenId to return the metadata for.
   */
  function tokenURI(uint256 tokenId_)
  public
  view
  override
  returns (string memory)
  {
    require(tokenId_ >= 0 && tokenId_ < MAX_SUPPLY, "$BEACH: TokenID does not exist");

    return
    string(
      abi.encodePacked(
        "data:application/json;base64,",
        BeachLibrary.encode(
          bytes(
            string(
              abi.encodePacked(
                abi.encodePacked('{"name": "', beachName(tokenId_), '",'),
                '"description": "BEACH", ',
                '"token_id": ', Strings.toString(tokenId_), ', ',
                '"art_number": ', Strings.toString(tokenId_ + 1), ', ',
                _revealed ? abi.encodePacked('"image": "', _baseURI(), getRevealedPath(tokenId_), '/', tokenId_, '.png",') : abi.encodePacked('"image": "', _baseURI(), _placeholderURI, '",'),
                _revealed ? abi.encodePacked('"image": "', _baseURI(), getRevealedPath(tokenId_), '/', tokenId_, '_large.png",') : abi.encodePacked('"image": "', _baseURI(), _placeholderURI, '",'),
                '"attributes":',
                _revealed ? hashToMetadata(tokenId_) : '[]',
                "}"
              )
            )
          )
        )
      )
    );
  }

  modifier mintOpened() {
    require(block.number > _mintBlock, "BEACH: Mint block not ready");
    _;
  }

  modifier revealedStatus(bool revealStatus_) {
    require(_revealed == revealStatus, string(abi.encodePacked("BEACH: REVEAL status is not ", revealStatus ? "TRUE" : "FALSE")));
    _;
  }

  function gimmeBeaches(uint8 count_, bool isWaveList_, bytes32[] calldata merkleProof_) external payable mintOpened {
    require(count_ <= 5, "GetABeach: MAX 5 beaches at once");
    require(balanceOf(_msgSender()) + count_ < 10, "Beach: Too many beaches");

    if (isWaveList_) {
      require(MerkleProof.verify(merkleProof_, waveListMerkleRoot, keccak256(abi.encodePacked(_msgSender()))), "BEACH: Not found in waveList");
    }

    require(msg.value == getMyPriceForNextMint(isWaveList_), "Beach: Minting amount incorrect");

    for (uint8 i = 0; i < count_; i++) {
      _mintABeach(_msgSender());
    }
  }

  function safeMint(address to) public onlyOwner {
    require(_tokenIdCounter < MAX_SUPPLY, "BEACH: mint reached max supply");
    _safeMint(to, _tokenIdCounter);
    _setName(_tokenIdCounter, Strings.toString(_tokenIdCounter));
  unchecked {
    _tokenIdCounter += 1;
  }
  }

  function _mintABeach(address to) private {
    require(_tokenIdCounter < MAX_SUPPLY, "BEACH: mint reached max supply");
    _safeMint(to, _tokenIdCounter);
    _setName(_tokenIdCounter, Strings.toString(_tokenIdCounter));
  unchecked {
    _tokenIdCounter += 1;
  }
  }

  /**
   * Name management
   */
  function setName(uint tokenId_, string memory name_) public {
    address owner = IERC721(address(this)).ownerOf(tokenId_);
    require(owner == _msgSender(), "BEACH: You do not own this token");
    require(validateName(name_), "BEACH: Name is not valid");
    require(nameExists(name_) == false, "BEACH: Name requested is already used, please chose another");
    require(resolveSeafoodBalance(_msgSender()) > AMOUNT_NEEDED_FOR_NAME_CHANGE, "BEACH: You do not have enough $BEACH balance to change the name");

    // Burn $BEACH
    _burnSeafoodToken(AMOUNT_NEEDED_FOR_NAME_CHANGE);
    _setName(tokenId_, name_);
  }

  function _setName(uint tokenId_, string memory name_) private {
    if (bytes(_beachNames[tokenId_]).length > 0) {
      _existingNames[_beachNames[tokenId_]] = false;
    }
    _beachNames[tokenId_] = name_;
    _existingNames[toLower(name_)] = true;
    emit NameChanged(name_);
  }

  function nameExists(string memory name_) public view returns (bool) {
    return _existingNames[toLower(name_)];
  }

  function beachName(uint tokenId_) public view returns (string memory) {
    bool isEmpty = keccak256(abi.encodePacked(_beachNames[tokenId_])) == keccak256(abi.encodePacked("")) || keccak256(abi.encodePacked(_beachNames[tokenId_])) == keccak256(bytes(Strings.toString(tokenId_)));
    return string(abi.encodePacked("Beach ", isEmpty ? string(abi.encodePacked("#", Strings.toString(tokenId_))) : _beachNames[tokenId_]));
  }

  function validateName(string memory str) public pure returns (bool){
    bytes memory b = bytes(str);
    if (b.length < 1) return false;
    if (b.length > 25) return false;
    // Cannot be longer than 25 characters
    if (b[0] == 0x20) return false;
    // Leading space
    if (b[b.length - 1] == 0x20) return false;
    // Trailing space

    bytes1 lastChar = b[0];

    for (uint i; i < b.length; i++) {
      bytes1 char = b[i];

      if (char == 0x20 && lastChar == 0x20) return false;
      // Cannot contain continuous spaces

      if (
        !(char >= 0x30 && char <= 0x39) && //9-0
      !(char >= 0x41 && char <= 0x5A) && //A-Z
      !(char >= 0x61 && char <= 0x7A) && //a-z
      !(char == 0x20) //space
      )
        return false;

      lastChar = char;
    }

    return true;
  }

  /**
  * @dev Converts the string to lowercase
	 */
  function toLower(string memory str) public pure returns (string memory){
    bytes memory bStr = bytes(str);
    bytes memory bLower = new bytes(bStr.length);
    for (uint i = 0; i < bStr.length; i++) {
      // Uppercase character
      if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {
        bLower[i] = bytes1(uint8(bStr[i]) + 32);
      } else {
        bLower[i] = bStr[i];
      }
    }
    return string(bLower);
  }

  /**
   * $SEAFOOD management
   */
  function resolveSeafoodBalance(address account) internal view returns (uint) {
    return IERC20(_seafood).balanceOf(account);
  }

  // Takes a high order amount (for example 10) and returns fully decimal'ed value (10 * 10 ** 18)
  function _toFullDecimals(uint amount_) private view returns (uint) {
    return amount_ * 10 ** ISeafood(_seafood).decimals();
  }

  function _burnSeafoodToken(uint amount_) private returns (bool) {
    uint __amount = _toFullDecimals(amount_);
    require(resolveSeafoodBalance(_msgSender()) >= __amount, "BEACH: Not enough $BEACH balance to burn");
    IERC20Burnable(_seafood).burnFrom(_msgSender(), __amount);
    return true;
  }

  // The following functions are overrides required by Solidity.

  function _burn(uint256 tokenId) internal override(ERC721, ERC721Royalty) {}

  function _beforeTokenTransfer(address from, address to, uint256 tokenId)
  internal
  override(ERC721, ERC721Enumerable)
  {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
  public
  view
  override(ERC721, ERC721Enumerable, ERC721Royalty)
  returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  // Beach-specific functions

  /***************************
   *      Reveal / Mint      *
   ***************************/

  function setDict(string[] memory dict) public onlyOwner revealedStatus(false) {
    _DICT = dict;
  }

  function setMetadata(uint16[2] calldata range, uint16[][] calldata metadata) external onlyOwner returns (bool) {
    require(range[0] >= 0 && range[0] < range[1] && range[1] <= MAX_SUPPLY, "BEACH: Range incorrect");
    for (uint i = 0; i < range[1] - range[0]; i++) {
      uint tokenId_ = i + range[0];

      // Properties.TRAITS_SAND
      _beachMetadata[tokenId_][0] = metadata[i][0];
      // Properties.TRAITS_WATER
      _beachMetadata[tokenId_][1] = metadata[i][1];
      // Properties.TRAITS_WAVES
      _beachMetadata[tokenId_][2] = metadata[i][2];
      // Properties.TRAITS_SPARKLING
      _beachMetadata[tokenId_][3] = metadata[i][3];
      // Properties.TRAITS_LOCATION
      _beachMetadata[tokenId_][4] = metadata[i][4];
      // Properties.TRAITS_FRAME
      _beachMetadata[tokenId_][5] = metadata[i][5];
      // Properties.TRAITS_FEATURE
      _beachMetadata[tokenId_][6] = metadata[i][6];
      // Properties.TRAITS_SIGN
      _beachMetadata[tokenId_][7] = metadata[i][7];
    }

    return true;
  }

  function revealState() public view returns (bool) {
    return _revealed;
  }

  function reveal(string[] calldata paths) external onlyOwner {
    require(_revealed == false, "BEACH: _revealed already set");
    _revealed = true;
    _revealedPath[0] = paths[0];
    _revealedPath[1] = paths[1];
    emit Revealed();
  }

  function currentTokenId() public view returns (uint) {
    return _tokenIdCounter;
  }

  function resolveLobster(address target) public view returns (uint) {
    return IERC721(_lobster).balanceOf(target);
  }

  function getMyPriceForNextMint(bool isWaveList_) public view returns (uint) {
    uint lobsterBalance = resolveLobster(_msgSender());

    if (_tokenIdCounter < 137) {
      if (lobsterBalance >= 1 || isWaveList_) {
        return 0 ether;
      }
      return 1 ether;
    } else if (_tokenIdCounter >= 137 && _tokenIdCounter < 317) {
      if (lobsterBalance >= 1 || isWaveList_) {
        return 0.037 ether;
      }
      return 0.073 ether;
    } else if (_tokenIdCounter >= 317 && _tokenIdCounter < 713) {
      if (lobsterBalance >= 1) {
        return 0.073 ether;
      }
      return 0.1 ether;
    } else if (_tokenIdCounter >= 713) {
      if (lobsterBalance >= 1) {
        return 0.1 ether;
      }
      return 0.1337 ether;
    } else {
      return 1 ether;
    }
  }

  /**************************
   *    Payment Splitter    *
   **************************/

  function _addPayee(address account_, uint8 shares_) private {
    require(account_ != address(0), "PaymentSplitter: Address can't be 0");
    require(shares_ > 0, "PaymentSplitter: Shares can't be 0");
    require(_totalShares + shares_ < 256, "PaymentSplitter: Max shares reached");
    require(_shares[account_] == 0, "PaymentSplitter: Account already has shares");
    require(_released[account_] == 0, "PaymentSplitter: Released is non-0 for this account");
    require(_balances[account_] == 0, "PaymentSplitter: Balances is non-0 for this account");
    require(_payees.length < 256, "PaymentSplitter: Too many shareholders");

    _payees.push(account_);
    _shares[account_] = shares_;
    _released[account_] = 0;
    _balances[account_] = 0;
    _totalShares += shares_;

    emit PayeeAdded(account_, shares_);
  }

  function addPayee(address account_, uint8 shares_) external onlyOwner {
    _addPayee(account_, shares_);
  }

  function addPayeesBatch(address[] calldata accounts_, uint8[] calldata shares_) external onlyOwner {
    for (uint8 i = 0; i < accounts_.length; i++) {
      _addPayee(account_[i], shares_[i]);
    }
  }

  function _updatePayee(address account_, uint8 shares_) private {
    require(account_ != address(0), "PaymentSplitter: Address can't be 0");
    require(_released[account_] > 0 || _balances[account_] > 0, "PaymentSplitter: Account doesn't exist");
    require(_totalShares - _shares[account_] + shares_ < 256, "PaymentSplitter: Max shares reached");

    uint8 sharesBefore = _shares[account_];

    // Update shares
    _shares[account_] = shares_;

    // Adjust total shares
    _totalShares = _totalShares - sharesBefore + shares_;

    emit PayeeUpdated(account_, shares_);
  }

  function updatePayee(address account_, uint8 shares_) external onlyOwner {
    _updatePayee(account_, shares_);
  }

  function updatePayeesBatch(address[] calldata accounts_, uint8[] calldata shares_) external onlyOwner {
    for (uint8 i = 0; i < accounts_.length; i++) {
      _updatePayee(account_[i], shares_[i]);
    }
  }

  function _split(uint amount) private {
    for (uint8 i = 0; i < _payees.length; i++) {
      // Only calculate if the shares are not 0 to avoid un-needed calculations
      if (_shares[_payees[i]] > 0) {
        uint256 amountSplit = amount * _shares[_payees[i]] / _totalShares;
        _balances[_payees[i]] += amountSplit;
        _totalSplit += amountSplit;
      }
    }
  }

  function _splitOutstandingBalance() internal {
    uint outstandingBalance = address(this).balance - _totalSplit;
    _split(outstandingBalance);
  }

  function split() external onlyAccountOrOwner {
    _splitOutstandingBalance();
  }

  function release(address payable account) external onlyAccountOrOwner(account) {
    require(_balances[account] > 0, "PaymentSplitter: Account has no balance");

    _splitOutstandingBalance();

    // Non-re-entrant pre-tx
    uint256 amountToSend = _balances[account];
    _balances[account] = 0;

    Address.sendValue(account, amountToSend);

    // Post-tx book-keeping
    _released[account] = _released[account] + amountToSend;
    _amountReleased = _amountReleased + amountToSend;

    emit PaymentReleased(account, amountToSend);
  }

  function accountBalance(address account) public view onlyAccountOrOwner(account) returns (uint256) {
    return _balances[account];
  }

  function totalReceived() public view returns (uint256) {
    return address(this).balance + _amountReleased;
  }

  modifier onlyAccountOrOwner(address account) {
    require(owner() == _msgSender() || account == _msgSender(), "Caller is not the owner nor the account owner");
    _;
  }
}
